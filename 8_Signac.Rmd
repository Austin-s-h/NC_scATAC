Creating Seurat objects from existing scATAC-Seq with 10X Genomics data
-----------------------------------------------------------------------

# FILEPATH: /workspaces/NC_scATAC/8_Signac.Rmd

This section of code creates 5000 bp bin count matrices for the original pass of 10X Genomics scATAC-Seq data.
It also incorporates the additional HH6_NPB and HH18_SORT cells ATAC signal from new multiome.
The data then undergoes a first, less stringent, pass of quality control (QC) and filtering. 
Peaks are called per-sample using MACS2. NOTE, a sensitivity analysis of this vs. calling by cluster in the final 
integrated data is needed.

```{r}
library(renv)
renv::activate()
# install.packages("SeuratObject")
# remotes::install_github("stuart-lab/signac", ref = "develop")
# install.packages("BSgenome.Ggallus.ENSEMBL.galGal6_1.0.3.tar.gz", repos = NULL)

suppressPackageStartupMessages({
  library(BSgenome.Ggallus.ENSEMBL.galGal6)
  library(GenomicFeatures)
  library(RMariaDB)
  library(org.Gg.eg.db)
  library(dplyr)
  library(JASPAR2020)
  library(Seurat) # 5
  library(Signac) # develop >1.12.0
  library(ggplot2)
  library(AnnotationHub)
  library(ensembldb)
  library(Biostrings)
  library(Matrix) # 1.6.4
  library(irlba)
})
options(future.globals.maxSize = 20 * 1024^3) # set to 20 Gb for sparse -> dense matrix conversion
plan("multicore", workers = 18)
ah <- AnnotationHub()
qr <- query(ah, c("EnsDb", "gallus gallus", "95"))
EnsDb_gg6 <- ah[["AH67945"]]
# extract gene annotations from EnsDb
annotations <- suppressWarnings(GetGRangesFromEnsDb(ensdb = EnsDb_gg6))
```


## Create Seurat objects from 10X Genomics scATAC-Seq data

```{r}
seurat_list <- list()
bins <- unlist(tileGenome(seqlengths = seqlengths(EnsDb_gg6), tilewidth = 5000))

for (s in c("HH6", "HH8", "HH10", "HH12", "HH14", "HH16", "HH18")) {
  prefix <- "data/10xscATAC_Lane1_Lane2_outs/"
  fragpath <- c(paste0(prefix, s, "/", s, "_fragments.tsv.gz"))
  input_csv_file <- c(paste0(prefix, s, "/", s, "_singlecell.csv"))
  # Load data
  print(paste0("Reading ", fragpath, " and ", input_csv_file))
  metadata <- read.csv(file = input_csv_file, header = TRUE, row.names = 1)
  print(paste0("Creating Seurat object from", nrow(metadata), " unfiltered cells cells."))
  # Create a fragment object
  barcode_names <- rownames(metadata[which(metadata$is__cell_barcode == 1), ])
  print(paste0(
    "Creating fragment object with ", length(barcode_names),
    " cells. (Prefiltered from 10X Genomics)"
  ))
  frags <- CreateFragmentObject(path = fragpath, cells = barcode_names)
  # counts <- FeatureMatrix(fragments = frags, features = bins, cells = barcode_names)
  counts <- GenomeBinMatrix(
    fragments = frags, genome = seqinfo(EnsDb_gg6),
    cells = barcode_names, binsize = 5000, process_n = 2000, sep = c("-", "-"),
    verbose = TRUE
  )
  count_name_gr <- StringToGRanges(rownames(counts), sep = c("-", "-"))
  # Create a chromatin object
  assay <- CreateChromatinAssay(
    counts = counts,
    min.features = 1000,
    ranges = count_name_gr,
    fragments = frags,
    annotation = annotations,
    genome = seqinfo(EnsDb_gg6)
  )
  seurat <- CreateSeuratObject(
    counts = assay,
    assay = "bins5000",
    project = paste0(s, "_ATAC"),
    meta.data = metadata
  )
  # Add the Seurat object to the list
  seurat_list[[s]] <- seurat
}

# Add in the additional HH6_NPB and HH18_SORT cells atac signal from multiome
for (s in c("HH6_NPB", "HH18_SORT")) {
  prefix <- c(paste0(s, "_Multiome_95/outs/"))
  fragpath <- c(paste0(prefix, "atac_fragments.tsv.gz"))
  input_csv_file <- c(paste0(prefix, "filtered_feature_bc_matrix/barcodes.tsv.gz"))
  # Load data
  print(paste0("Reading ", fragpath, " and ", input_csv_file))
  barcode_names <- read.csv(file = input_csv_file, header = FALSE)
  barcode_names <- barcode_names[, 1]
  print(paste0(
    "Creating fragment object with ", length(barcode_names),
    " cells. (Prefiltered from 10X Genomics)"
  ))
  frags <- CreateFragmentObject(path = fragpath, cells = barcode_names)
  # counts <- FeatureMatrix(fragments = frags, features = bins, cells = barcode_names)
  counts <- GenomeBinMatrix(
    fragments = frags, genome = seqinfo(EnsDb_gg6),
    cells = barcode_names, binsize = 5000, process_n = 2000, sep = c("-", "-"),
    verbose = TRUE
  )
  count_name_gr <- StringToGRanges(rownames(counts), sep = c("-", "-"))
  # Create a Chromatin assay
  assay <- CreateChromatinAssay(
    counts = counts,
    ranges = count_name_gr,
    fragments = frags,
    annotation = annotations,
    genome = seqinfo(EnsDb_gg6)
  )
  seurat <- CreateSeuratObject(
    counts = assay,
    assay = "bins5000",
    project = paste0(s, "_ATAC"),
  )
  # Add the Seurat object to the list
  seurat_list[[s]] <- seurat
}

saveRDS(seurat_list, file = "data/seurat_list_3.rds", compress = FALSE)
```

## QC and filtering

```{r}
seurat_list <- readRDS(file = "data/seurat_list_3.rds")

# Previously used first pass QC metrics
# "HH8", "HH10", "HH12", "HH14", "HH16", "HH18", "HH6_NPB", "HH18_SORT"
for (s in c("HH6", "HH8", "HH10", "HH12", "HH14", "HH16", "HH18", "HH6_NPB", "HH18_SORT")) {
  seurat_obj <- seurat_list[[s]]
  head(seurat_obj@meta.data)
  seurat_obj <- NucleosomeSignal(seurat_obj)
  seurat_obj$nucleosome_group <- ifelse(seurat_obj$nucleosome_signal > 4, "NS > 4", "NS < 4")
  FragmentHistogram(object = seurat_obj, group.by = "nucleosome_group", region = "1-1-100000")
  seurat_obj <- TSSEnrichment(seurat_obj, fast = FALSE)
  seurat_obj$high.tss <- ifelse(seurat_obj$TSS.enrichment > 2, "High", "Low")
  tss <- TSSPlot(seurat_obj, group.by = "high.tss") + NoLegend()
  ggsave(tss, filename = paste0("export/", s, "_QC_TSS.pdf"), width = 8, height = 8)
  vln <- VlnPlot(
    object = seurat_obj,
    features = c(
      "TSS.enrichment", "nFeature_bins5000",
      "mitochondrial", "TSS.percentile"
    ),
    pt.size = 0.1,
    ncol = 5
  )
  ggsave(vln, filename = paste0("export/", s, "_QC_violin.pdf"), width = 12, height = 8)
  seurat_obj <- BinarizeCounts(seurat_obj)
  # remove features that are very low counts
  seurat_obj <- subset(
    x = seurat_obj,
    subset = nFeature_bins5000 > 5
  )
  seurat_obj <- RunTFIDF(seurat_obj)
  seurat_obj <- FindTopFeatures(seurat_obj, min.cutoff = "q20")
  seurat_obj <- RunSVD(object = seurat_obj)
  DepthCor(seurat_obj)

  seurat_obj <- RunUMAP(
    object = seurat_obj,
    reduction = "lsi",
    dims = 2:30,
  )
  seurat_obj <- FindNeighbors(
    object = seurat_obj,
    reduction = "lsi",
    dims = 2:30
  )
  seurat_obj <- FindClusters(
    object = seurat_obj,
    algorithm = 2,
    resolution = 0.5,
    verbose = FALSE
  )


  umap <- DimPlot(object = seurat_obj, label = TRUE, reduction = "umap") + NoLegend()
  ggsave(umap, filename = paste0("export/", s, "pre_filter_UMAP.pdf"), width = 8, height = 8)
  seurat_obj <- subset(
    x = seurat_obj,
    subset = nFeature_bins5000 > 1250 &
      nFeature_bins5000 < 100000 &
      nucleosome_signal < 4 &
      TSS.enrichment > 2
  )
  outdir <- paste0("export/peaks/", s, "_macs2")
  if (!dir.exists(outdir)) {
    dir.create(outdir, recursive = TRUE)
  }
  # grouping by timepoint (sample) only
  peaks <- CallPeaks(seurat_obj,
    group.by = NULL,
    macs2.path = "/home/vscode/.local/bin/macs2",
    effective.genome.size = 1218492533,
    outdir = paste0("export/peaks/", s, "_macs2"),
    extsize = 73, shift = 37,
    additional.args = "--nomodel",
    cleanup = FALSE,
    name = paste0(s, "prefiltered_macs2")
  )
  saveRDS(peaks, file = paste0("export/peaks/", s, "_macs2/peaks.rds"), compress = FALSE)

  seurat_list[[s]] <- seurat_obj
}

saveRDS(seurat_list, file = "data/seurat_list_4.rds", compress = FALSE)
```


## Merge peaks

```{r}
# combine peaks
peaks_list <- list()
for (s in c("HH6", "HH8", "HH10", "HH12", "HH14", "HH16", "HH18", "HH6_NPB", "HH18_SORT")) {
  peaks <- readRDS(file = paste0("export/peaks/", s, "_macs2/peaks.rds"))
  peaks_list[[s]] <- peaks
}

# Create a unified set of peaks to quantify in each dataset
combined_peaks <- GenomicRanges::reduce(
  x = c(
    peaks_list[["HH6"]],
    peaks_list[["HH8"]],
    peaks_list[["HH10"]],
    peaks_list[["HH12"]],
    peaks_list[["HH14"]],
    peaks_list[["HH16"]],
    peaks_list[["HH18"]]
  )
)
# filter seqinfo to only contain chromosomes from trimmed_peaks
chromosomes <- levels(seqnames(combined_peaks))
seq_info <- seqinfo(BSgenome.Ggallus.ENSEMBL.galGal6)[chromosomes]
seqinfo(combined_peaks) <- seq_info
trimmed_peaks <- trim(combined_peaks)
summary(combined_peaks %in% trimmed_peaks)

## BUG??? TRIM TO BSGENOME SEQLENGTHS - literally one peak -.-

# Filter out bad peaks based on length
peakwidths <- width(trimmed_peaks)
trimmed_peaks <- trimmed_peaks[peakwidths < 10000 & peakwidths > 20]
trimmed_peaks
trimmed_peaks <- trimmed_peaks[!duplicated(trimmed_peaks), ]
saveRDS(trimmed_peaks,
  file = "export/peaks/combined_5000b_peakset_gr.rds",
  compress = FALSE
)
```

## Quantify on combined peakset

```{r}
# Make sure to activate env fully
seurat_list <- readRDS(file = "data/seurat_list_4.rds")
combined_peaks <- readRDS(file = "export/peaks/combined_5000b_peakset_gr.rds")
seurat_list_2 <- list()
for (s in c("HH6", "HH8", "HH10", "HH12", "HH14", "HH16", "HH18")) {
  prefix <- "data/10xscATAC_Lane1_Lane2_outs/"
  # Instead of using metadata, use the prefiltered cells from the previous step
  barcode_names <- rownames(seurat_list[[s]]@meta.data)
  fragpath <- c(paste0(prefix, s, "/", s, "_fragments.tsv.gz"))
  input_csv_file <- c(paste0(prefix, s, "/", s, "_singlecell.csv"))
  # Load data
  print(paste0("Reading ", fragpath, " and ", input_csv_file))
  metadata <- read.csv(file = input_csv_file, header = TRUE, row.names = 1)
  print(paste0(
    "Creating Seurat object from", nrow(metadata),
    " unfiltered cells cells. After 5000 bin QC, there are ",
    length(barcode_names), "cells remaining."
  ))
  # Create a fragment object
  frags <- CreateFragmentObject(path = fragpath, cells = barcode_names)
  counts <- FeatureMatrix(
    fragments = frags, features = combined_peaks,
    cells = barcode_names
  )
  # Create a chromatin object
  assay <- CreateChromatinAssay(
    counts = counts,
    ranges = combined_peaks,
    fragments = frags,
    annotation = annotations,
    genome = seqinfo(EnsDb_gg6)
  )
  seurat_obj <- CreateSeuratObject(
    counts = assay,
    assay = "peaks",
    project = paste0(s, "_ATAC"),
    meta.data = metadata
  )
  seurat_list_2[[s]] <- seurat_obj
}

# Add in the additional HH6_NPB and HH18_SORT cells atac signal from multiome
for (s in c("HH6_NPB", "HH18_SORT")) {
  prefix <- c(paste0(s, "_Multiome_95/outs/"))
  fragpath <- c(paste0(prefix, "atac_fragments.tsv.gz"))
  input_csv_file <- c(paste0(prefix, "filtered_feature_bc_matrix/barcodes.tsv.gz"))
  # Load data
  print(paste0("Reading ", fragpath, " and ", input_csv_file))
  barcode_names <- rownames(seurat_list[[s]]@meta.data)
  print(paste0(
    "Creating fragment object with ", length(barcode_names),
    " cells. (Remaining after 5000 bin QC)"
  ))
  frags <- CreateFragmentObject(path = fragpath, cells = barcode_names)
  counts <- FeatureMatrix(
    fragments = frags, features = combined_peaks,
    cells = barcode_names
  )
  # Create a Chromatin assay
  assay <- CreateChromatinAssay(
    counts = counts,
    ranges = combined_peaks,
    fragments = frags,
    annotation = annotations,
    genome = seqinfo(EnsDb_gg6)
  )
  seurat_obj <- CreateSeuratObject(
    counts = assay,
    assay = "peaks",
    project = paste0(s, "_ATAC")
  )
  seurat_list_2[[s]] <- seurat_obj
}

saveRDS(seurat_list_2, file = "data/seurat_list_5.rds", compress = FALSE)
```


## Performing integration WORKING CHUNK

This is where things start to get interesting. We finally have a single Seurat object with all of the data.
I just need to run this again to make sure it saves.
```{r}
seurat_list_2 <- readRDS(file = "data/seurat_list_5.rds")
# merge all datasets, adding a cell ID to make sure cell names are unique
combined <- merge(
  x = seurat_list_2[["HH6"]],
  y = list(
    seurat_list_2[["HH6_NPB"]], seurat_list_2[["HH8"]],
    seurat_list_2[["HH10"]], seurat_list_2[["HH12"]],
    seurat_list_2[["HH14"]], seurat_list_2[["HH16"]],
    seurat_list_2[["HH18"]], seurat_list_2[["HH18_SORT"]]
  ),
  add.cell.ids = c(
    "HH6", "HH6_NPB", "HH8", "HH10", "HH12", "HH14", "HH16",
    "HH18", "HH18_SORT"
  )
)
combined
# 32,999 cells quantified across 335956 peaks
# Remove metadata that is not used/invalid
summary(combined@meta.data)

# Remove metadata columns that are not used/invalid
combined@meta.data[, c(
  "DNase_sensitive_region_fragments", "enhancer_region_fragments",
  "promoter_region_fragments", "blacklist_region_fragments"
)] <- NULL
summary(combined@meta.data)
```

```{r}
combined <- NucleosomeSignal(combined)
combined$nucleosome_group <- ifelse(combined$nucleosome_signal > 4, "NS > 4", "NS < 4")
FragmentHistogram(object = combined, group.by = "nucleosome_group", region = "1-1-100000")
combined <- TSSEnrichment(combined, fast = FALSE)
combined$high.tss <- ifelse(combined$TSS.enrichment > 2, "High", "Low")
tss <- TSSPlot(combined, group.by = "high.tss") + NoLegend()
ggsave(tss, filename = paste0("export/combined_QC_TSS.pdf"), width = 8, height = 8)
vln <- VlnPlot(
  object = combined,
  features = c(
    "TSS.enrichment", "nFeature_bins5000",
    "mitochondrial", "TSS.percentile"
  ),
  pt.size = 0.1,
  ncol = 5
)
ggsave(vln, filename = paste0("export/combined_QC_violin.pdf"), width = 12, height = 8)
combined <- BinarizeCounts(combined)
combined <- ScaleData(combined, assay = "peaks", model.use = "negbinom")
# remove features that are very low counts
combined <- RunTFIDF(combined)
combined <- FindTopFeatures(combined, min.cutoff = "q10")
combined <- RunSVD(object = combined, n = 50, reduction.name = "lsi")
DepthCor(combined)

# Refine cluster resolution
# Iterate here to find the best resolution
combined <- RunUMAP(
  object = combined,
  reduction = "lsi",
  dims = 2:50,
  n.neighbors = 30,
  n.components = 2,
  min.dist = 0.3,
)
combined <- FindNeighbors(
  object = combined,
  reduction = "lsi",
  dims = 2:50,
)
combined <- FindClusters(
  object = combined,
  algorithm = 2,
  resolution = 0.5,
  verbose = FALSE,
  group.singletons = TRUE,
  cluster.name = "lsi_clusters0.5"
)

umap <- DimPlot(object = combined, label = TRUE, reduction = "umap")
ggsave(umap, filename = paste0("export/combined_suerat_lsi_clusters0.5.pdf"), width = 8, height = 8)
umap <- DimPlot(object = combined, label = TRUE, group.by = "orig.ident", reduction = "umap")
ggsave(umap, filename = paste0("export/combined_suerat_lsi_clusters0.5_UMAP_orig.ident.pdf"), width = 8, height = 8)

saveRDS(combined, file = "data/combined_seurat_obj.rds", compress = FALSE)
```